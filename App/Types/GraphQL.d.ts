export const typeDefs = ["# Autogenerated input type of AcceptCoop\ninput AcceptCoopInput {\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n  id: String!\n}\n\n# Autogenerated return type of AcceptCoop\ntype AcceptCoopPayload {\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n  coopRequest: CoopRequest\n  errors: [String!]!\n}\n\n# Autogenerated input type of AcceptFriend\ninput AcceptFriendInput {\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n\n  # Friend request ID to accept\n  id: String!\n}\n\n# Autogenerated return type of AcceptFriend\ntype AcceptFriendPayload {\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n  errors: [String!]!\n  friend: User!\n  friendRequest: FriendRequest\n  user: User!\n}\n\n# An Achievement is a collection of objectives\n# a user must complete before having \"achieved\"\n# something. When a user completes an Achievement,\n# the points awarded are based on which Achievement.category,\n# Achievement.kind, and Achievement.mode the Achievement\n# had, together with the sum of all its objective's points.\n#\n# ### Personal vs Global\n# Achievements may be personal, or global.\n# When a user creates a new Achievement,\n# this Achievement is always considered to be\n# /personal/. This means the Achievement\n# is only accessible to the user who created it,\n# and any users that it has been /shared/ with,\n# and so it will not show up in the normal Achievement\n# search queries, but must be queried for by ID,\n# or by searching specifically for a users \"personal\"\n# Achievements. \n#\n# ### Voting\n# If a user wishes to make his / her Achievement\n# globally accessible to everybody, he/she may set\n# the flag Achievement.is_suggested_global.\n# This allows the Achievement to show up as a community\n# Achievement, and enables it to receive upvotes,\n# or downvotes (check the mutations).\n#\n# It's yet to be decided what the threshold for\n# upvotes/downvotes should be before an Achievement\n# is made global, but it should probably be a few hundred\n# upvotes, and a ratio of upvotes:downvotes of more than 3:1.\ntype Achievement {\n  # User who created the Achievement\n  author: User!\n\n  # Achievements may have additional basePoints used to calculate Achievement.points\n  basePoints: Int!\n\n  # Category the Achievement belongs to, e.g Food & Culinary, Culture, etc.\n  category: Category!\n  downvotes: Int!\n  expires: Int\n\n  # Entire description. This may be very long.\n  fullDescription: String\n\n  # Does this Achievement depend on other Achievements? (BETA)\n  hasParents: Boolean!\n\n  # An icon from the specified subset of MaterialCommunityIcons\n  icon: Icon!\n  id: ID!\n\n  # Whether or not the Achievement is available to everybody\n  isGlobal: Boolean!\n\n  # Does this Achievement allow users to complete it as a group? Default: true\n  isMultiPlayer: Boolean!\n\n  # Has the owner suggested this Achievement to be evaluated by the community?\n  isSuggestedGlobal: Boolean!\n\n  # Achievement type, e.g ACTION, DISCOVERY, LOCATION, ROUTE\n  kind: Kind!\n\n  # Difficulty. One of: DIFFICULT, EASY, EXTREME, NORMAL\n  mode: Mode!\n  name: String!\n\n  # All linked Objectives. Objectives may belong to multiple Achievements.\n  objectives: [Objective!]!\n\n  # Calculated points awarded for completing the Achievement\n  points: Float!\n\n  # Ellipsized first 100 characters of the description, before the first newline\n  shortDescription: String!\n\n  # Whether or not the user has unlocked this Achievement\n  unlocked: Boolean!\n  upvotes: Int!\n}\n\n# The connection type for Achievement.\ntype AchievementConnection {\n  # A list of edges.\n  edges: [AchievementEdge]\n\n  # Information to aid in pagination.\n  pageInfo: PageInfo!\n}\n\n# An edge in a connection.\ntype AchievementEdge {\n  # A cursor for use in pagination.\n  cursor: String!\n\n  # The item at the end of the edge.\n  node: Achievement\n}\n\n# Autogenerated input type of AddFriend\ninput AddFriendInput {\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n  message: String\n\n  # User to send a friend request to\n  userId: String!\n}\n\n# Autogenerated return type of AddFriend\ntype AddFriendPayload {\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n  errors: [String!]!\n  friendRequest: FriendRequest\n  user: User!\n}\n\n# Autogenerated input type of AddToList\ninput AddToListInput {\n  achievementIds: [String!]!\n\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n\n  # ID of the list to add achievements to\n  id: String!\n}\n\n# Autogenerated return type of AddToList\ntype AddToListPayload {\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n  errors: [String!]!\n  list: List\n}\n\n# Autogenerated input type of AuthenticateUser\ninput AuthenticateUserInput {\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n  provider: OauthProvider!\n  token: String!\n}\n\n# Autogenerated return type of AuthenticateUser\ntype AuthenticateUserPayload {\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n  errors: [String!]!\n  user: CurrentUser\n}\n\ntype Category {\n  icon: String!\n  id: ID!\n  points: Int!\n  title: String!\n}\n\n# The connection type for Category.\ntype CategoryConnection {\n  # A list of edges.\n  edges: [CategoryEdge]\n\n  # Information to aid in pagination.\n  pageInfo: PageInfo!\n}\n\n# An edge in a connection.\ntype CategoryEdge {\n  # A cursor for use in pagination.\n  cursor: String!\n\n  # The item at the end of the edge.\n  node: Category\n}\n\n# Autogenerated input type of CompleteObjective\ninput CompleteObjectiveInput {\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n  coordinates: [Float!]\n  id: String!\n  timestamp: Int!\n}\n\n# Autogenerated return type of CompleteObjective\ntype CompleteObjectivePayload {\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n  errors: [String!]!\n  objectiveProgress: ObjectiveProgress\n  unlockedAchievements: [Unlocked!]\n}\n\ntype Continent {\n  id: ID!\n  name: String!\n  regions: [Region!]!\n}\n\n# The connection type for Continent.\ntype ContinentConnection {\n  # A list of edges.\n  edges: [ContinentEdge]\n\n  # Information to aid in pagination.\n  pageInfo: PageInfo!\n}\n\n# An edge in a connection.\ntype ContinentEdge {\n  # A cursor for use in pagination.\n  cursor: String!\n\n  # The item at the end of the edge.\n  node: Continent\n}\n\n# Cooperation Requests can be sent from any Achievement,\n# to any other user in the area, to ask whether or not they\n# would like to meet up and complete the Achievement together.\n# When a CoopRequest is sent, the user may receive a notification\n# like 'Annie has invited you to complete an Achievement',\n# and once the other party has accepted the invitation, both users\n# are now in *coop mode* for this Achievement, and will receive\n# bonus points for completing it.\n#\n# Cooperation Requests can also be sent for *lists*, which binds\n# users to receive a coop bonus for any of the Achievements in the\n# list, provided they complete the Achievement within 5 minutes of\n# eachother. It doesn't matter if one of the users is without internet\n# connection or not, because as soon as he/she connects and unlocks\n# the Achievement, both will be awarded bonus points.\n#\n# ### Bonus calculation\n# Coop bonus is calculated as: `Achievement.points * 0.8^N`,\n# where N is the amount of times users have cooperated together\n# before, but never goes below 3. This means that each time you\n# complete an Achievement with somebody, you get +80% extra points,\n# and the next time you complete an Achievement with the same person,\n# you get 80% of those 80% extra points, and so on. This causes\n# *diminishing returns*, where it will **always** be beneficial\n# for you to complete Achievements with other people, but it will\n# always be *more* beneficial to complete Achievements with new people.\n#\n# ### Groups\n# Lets say Annie and her boyfriend Barry always go together, but have\n# decided to meet up with a new third person, Claire. \n# If the user is in multiplayer/cooperation mode with **several** users,\n# the coop bonus **does not compound**. Annie **will not** receive +80%\n# for cooperating with Claire and another bonus for Barry. \n# Instead, the users **always gets the highest coop bonus available to them**.\n#\n# This incentivizes inviting new people, because even if you always\n# unlock Achievements with a friend, inviting at least one new person\n# everytime, ensures everybody gets an additional 80% extra points.\n#\n# ### Practicality\n# TODO: When a user accepts a CoopRequest, we should perhaps provide a\n# time and location for them to meet up, but without knowing either users\n# location, this is difficult. Instead, we may need to introduce a way for\n# users to either a) message eachother or b) agree on a meetup point.\ntype CoopRequest {\n  # Achievement the coop request applies to. May be null if a list is given\n  achievement: Achievement\n  createdAt: Int!\n  id: ID!\n\n  # Has the receiving user accepted the request?\n  isAccepted: Boolean!\n\n  # When the request is accepted, and the objective has been completed for both users, this will be true\n  isComplete: Boolean!\n\n  # CoopRequest is pending until the receiving user accepts it\n  isPending: Boolean!\n\n  # List the coop request applies to. May be null if an Achievement is given.\n  list: List\n\n  # User who received this request\n  receiver: User!\n\n  # User who sent this request\n  sender: User!\n  updatedAt: Int!\n}\n\ntype Country {\n  id: ID!\n  name: String!\n  region: Region!\n}\n\n# The connection type for Country.\ntype CountryConnection {\n  # A list of edges.\n  edges: [CountryEdge]\n\n  # Information to aid in pagination.\n  pageInfo: PageInfo!\n}\n\n# An edge in a connection.\ntype CountryEdge {\n  # A cursor for use in pagination.\n  cursor: String!\n\n  # The item at the end of the edge.\n  node: Country\n}\n\n# Autogenerated input type of Create\ninput CreateInput {\n  categoryId: Int!\n\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n  description: String!\n  icon: Icon!\n  mode: Mode!\n  name: String!\n  objectives: [ObjectiveInput!]!\n}\n\n# Autogenerated input type of CreateList\ninput CreateListInput {\n  # List of Achievement IDs to add to the list\n  achievementIds: [String!]\n\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n\n  # Whether or not this list should be visible for other users\n  isPublic: Boolean = false\n\n  # Name of the list\n  title: String!\n}\n\n# Autogenerated return type of CreateList\ntype CreateListPayload {\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n  errors: [String!]!\n  list: List\n}\n\n# Autogenerated return type of Create\ntype CreatePayload {\n  achievement: Achievement\n\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n  errors: [String!]!\n}\n\n#       Same as UserType, but always contains a new authenticationToken\n#       the user may use to authenticate.\n#\n#       TODO: Cache this token, instead of generating a new one on every request.\ntype CurrentUser {\n  authenticationToken: String!\n  coopPoints: Int!\n  country: Country!\n  email: String!\n  id: ID!\n  name: String!\n  personalPoints: Float!\n  points: Float!\n  role: Role!\n\n  # All Achievements unlocked by the user\n  unlockedAchievements(\n    # Returns the elements in the list that come after the specified cursor.\n    after: String\n\n    # Returns the elements in the list that come before the specified cursor.\n    before: String\n\n    # Returns the first _n_ elements from the list.\n    first: Int\n\n    # Returns the last _n_ elements from the list.\n    last: Int\n  ): UnlockedConnection!\n  unlockedCount: Int!\n\n  # All Achievements created by the user\n  userAchievements(\n    # Returns the elements in the list that come after the specified cursor.\n    after: String\n\n    # Returns the elements in the list that come before the specified cursor.\n    before: String\n\n    # Returns the first _n_ elements from the list.\n    first: Int\n\n    # Returns the last _n_ elements from the list.\n    last: Int\n  ): AchievementConnection!\n}\n\n# Autogenerated input type of Delete\ninput DeleteInput {\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n  id: String!\n}\n\n# Autogenerated return type of Delete\ntype DeletePayload {\n  achievement: Achievement\n\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n  errors: [String!]!\n  objectives: [Objective!]\n}\n\n# Autogenerated input type of Downvote\ninput DownvoteInput {\n  # Achievement to downvote\n  achievementId: String!\n\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n}\n\n# Autogenerated return type of Downvote\ntype DownvotePayload {\n  achievement: Achievement\n\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n  errors: [String!]!\n}\n\n# Friend requests lets users add other users as their friends,\n# and the main purpose of this is so that when a user links\n# their account with a social network, if he/she allows us to\n# import their friends, we can find (or suggest) friends to\n# add.\n#\n# We use a Friend-model rather than a Follow-model so that\n# if we were to display recently completed Achievements by\n# friends on the Home-screen, the user must have explicitly\n# accepted the people who would see their unlocked Achievements\n# in their feed; whereas with a Follow-model, anybody could\n# keep track of the physical whereabouts of anybody else, at\n# any given time. Even if we do not track anybody's location,\n# seeing that somebody unlocked an Achievement near e.g the\n# Eiffel tower 5 minutes ago, gives you a pretty good idea that\n# they must be somewhere around the Eiffel tower.\n#\n# Because we consider this sensitive user information, users\n# must explicitly add, and accept, who is allowed to see when\n# they complete Achievements.\ntype FriendRequest {\n  createdAt: Int!\n  id: ID!\n\n  # Add a message to the user you're sending a request to\n  message: String!\n\n  # User who will receive the request\n  receiver: User!\n\n  # User who sent the request\n  sender: User!\n  updatedAt: Int!\n}\n\n#   Subset of MaterialCommunityIcons\nenum Icon {\n  # airballoon\n  airballoon\n\n  # airport\n  airport\n\n  # anchor\n  anchor\n\n  # anvil\n  anvil\n\n  # baby-buggy\n  baby_buggy\n\n  # bank\n  bank\n\n  # barcode-scan\n  barcode_scan\n\n  # baseball\n  baseball\n\n  # basketball\n  basketball\n\n  # beach\n  beach\n\n  # bike\n  bike\n\n  # binoculars\n  binoculars\n\n  # bone\n  bone\n\n  # boombox\n  boombox\n\n  # bow-tie\n  bow_tie\n\n  # bowling\n  bowling\n\n  # brain\n  brain\n\n  # bridge\n  bridge\n\n  # briefcase\n  briefcase\n\n  # buddhism\n  buddhism\n\n  # bus\n  bus\n\n  # bus-clock\n  bus_clock\n\n  # bus-double-decker\n  bus_double_decker\n\n  # cake\n  cake\n\n  # cake-variant\n  cake_variant\n\n  # camera\n  camera\n\n  # camera-iris\n  camera_iris\n\n  # candle\n  candle\n\n  # candycane\n  candycane\n\n  # car\n  car\n\n  # car-convertible\n  car_convertible\n\n  # car-limousine\n  car_limousine\n\n  # caravan\n  caravan\n\n  # cards\n  cards\n\n  # cards-club\n  cards_club\n\n  # cards-diamond\n  cards_diamond\n\n  # cards-heart\n  cards_heart\n\n  # cards-outline\n  cards_outline\n\n  # cards-spade\n  cards_spade\n\n  # carrot\n  carrot\n\n  # cash\n  cash\n\n  # cassette\n  cassette\n\n  # castle\n  castle\n\n  # cat\n  cat\n\n  # cctv\n  cctv\n\n  # ceiling-light\n  ceiling_light\n\n  # certificate\n  certificate\n\n  # chess-knight\n  chess_knight\n\n  # chili-hot\n  chili_hot\n\n  # chili-mild\n  chili_mild\n\n  # chip\n  chip\n\n  # christianity\n  christianity\n\n  # church\n  church\n\n  # city\n  city\n\n  # cloud\n  cloud\n\n  # coffee\n  coffee\n\n  # coffee-outline\n  coffee_outline\n\n  # coffee-to-go\n  coffee_to_go\n\n  # cookie\n  cookie\n\n  # corn\n  corn\n\n  # cow\n  cow\n\n  # crane\n  crane\n\n  # creation\n  creation\n\n  # cube-outline\n  cube_outline\n\n  # cube-send\n  cube_send\n\n  # cup\n  cup\n\n  # duck\n  duck\n\n  # dumbbell\n  dumbbell\n\n  # earth\n  earth\n\n  # elevator\n  elevator\n\n  # escalator\n  escalator\n\n  # face\n  face\n\n  # factory\n  factory\n\n  # fan\n  fan\n\n  # feather\n  feather\n\n  # fire-truck\n  fire_truck\n\n  # fish\n  fish\n\n  # flag-variant\n  flag_variant\n\n  # flower\n  flower\n\n  # football-helmet\n  football_helmet\n\n  # forklift\n  forklift\n\n  # fountain\n  fountain\n\n  # gift\n  gift\n\n  # golf\n  golf\n\n  # gondola\n  gondola\n\n  # hammer\n  hammer\n\n  # hanger\n  hanger\n\n  # headphones\n  headphones\n\n  # hook\n  hook\n\n  # human-female\n  human_female\n\n  # human-male\n  human_male\n\n  # human-male-female\n  human_male_female\n\n  # ice-cream\n  ice_cream\n\n  # incognito\n  incognito\n\n  # infinity\n  infinity\n\n  # islam\n  islam\n\n  # judaism\n  judaism\n\n  # key-variant\n  key_variant\n\n  # knife-military\n  knife_military\n\n  # ladybug\n  ladybug\n\n  # lamp\n  lamp\n\n  # lead-pencil\n  lead_pencil\n\n  # leaf\n  leaf\n\n  # lifebuoy\n  lifebuoy\n\n  # map-outline\n  map_outline\n\n  # matrix\n  matrix\n\n  # motorbike\n  motorbike\n\n  # muffin\n  muffin\n\n  # music\n  music\n\n  # ninja\n  ninja\n\n  # oil\n  oil\n\n  # owl\n  owl\n\n  # palette\n  palette\n\n  # panda\n  panda\n\n  # pickaxe\n  pickaxe\n\n  # pier-crane\n  pier_crane\n\n  # pig\n  pig\n\n  # pill\n  pill\n\n  # pillar\n  pillar\n\n  # pine-tree\n  pine_tree\n\n  # pipe\n  pipe\n\n  # pokeball\n  pokeball\n\n  # poker-chip\n  poker_chip\n\n  # pool\n  pool\n\n  # popcorn\n  popcorn\n\n  # qrcode-scan\n  qrcode_scan\n\n  # restaurant\n  restaurant\n\n  # road-variant\n  road_variant\n\n  # rocket\n  rocket\n\n  # routes\n  routes\n\n  # run\n  run\n\n  # scale\n  scale\n\n  # scale-balance\n  scale_balance\n\n  # seat-individual-suite\n  seat_individual_suite\n\n  # shower\n  shower\n\n  # sign-direction\n  sign_direction\n\n  # snowflake\n  snowflake\n\n  # snowman\n  snowman\n\n  # soccer\n  soccer\n\n  # spray\n  spray\n\n  # stadium\n  stadium\n\n  # summit\n  summit\n\n  # sunglasses\n  sunglasses\n\n  # swim\n  swim\n\n  # sword\n  sword\n\n  # taxi\n  taxi\n\n  # tennis\n  tennis\n\n  # tent\n  tent\n\n  # tie\n  tie\n\n  # toilet\n  toilet\n\n  # tooth\n  tooth\n\n  # tractor\n  tractor\n\n  # train\n  train\n\n  # tram\n  tram\n\n  # tshirt-crew\n  tshirt_crew\n\n  # van-utility\n  van_utility\n\n  # voice\n  voice\n\n  # watch\n  watch\n\n  # water\n  water\n\n  # weather-sunset\n  weather_sunset\n\n  # worker\n  worker\n\n  # yin-yang\n  yin_yang\n}\n\nenum Kind {\n  # 25\n  ACTION\n\n  # 35\n  DISCOVERY\n\n  # 15\n  LOCATION\n\n  # 50\n  ROUTE\n}\n\n# Lists are containers for Achievements, designed\n# to let users, or the community, curate collections\n# of Achievements to complete for special purposes. \n# On a community scale, a List of Achievements could \n# be something like \"Winter is coming\", and contain\n# a set of winter-specific Achievements to complete.\n#\n# For users, it's important to be able to curate\n# their own lists, to easily be able to share a set\n# of custom Achievements to be completed with friends.\n# For example, if you were going on a hiking trip with\n# a group of friends, you may want to create a list\n# called *Hiking the Alps*, which could contain some\n# of the public Achievements in the alps, and maybe\n# some Achievements you've created yourself. Since\n# Achievements you've created yourself are only\n# accessible to the users you've shared it with,\n# putting them in a list and then sharing the list\n# is a quick and easy way to share multiple Achievements\n# and allow friends to complete non-public Achievements\n# together with you.\ntype List {\n  # Contents of the list. Can be updated by everybody the list has been shared with, and the author.\n  achievements: [Achievement!]\n\n  # User who created this list\n  author: User!\n  id: ID!\n\n  # Whether or not this list is available to everybody\n  isPublic: Boolean!\n\n  # Name of the list\n  title: String!\n}\n\nenum Mode {\n  # 15\n  DIFFICULT\n\n  # 5\n  EASY\n\n  # 20\n  EXTREME\n\n  # 10\n  NORMAL\n}\n\ntype Mutation {\n  #     Accepts a cooperation request by setting pending: false. Rejected\n  #     coop requests are deleted, so if a coop request has pending: false,\n  #     it's an active cooperation link between two users\n  acceptCoop(input: AcceptCoopInput!): AcceptCoopPayload\n\n  #     Identifies and accepts a friend request by id. The friend request\n  #     will be deleted, and the sender will be added to the user's friends.\n  #     Make sure to query for the friends connection, or the friend field,\n  #     and update the connection on the client.\n  acceptFriend(input: AcceptFriendInput!): AcceptFriendPayload\n\n  #   Identifies and adds a friend request by id. The friend request\n  #   will be deleted, and the sender will be added to the user's friends.\n  #   Make sure to query for the friends connection, or the friend field,\n  #   and update the connection on the client.\n  addFriend(input: AddFriendInput!): AddFriendPayload\n\n  #   Adds achievements to an existing list. User can only add\n  #   achievements to a list if a) the user owns it or b) the\n  #   list has been shared with the user and the user has been\n  #   granted access rights.\n  addToList(input: AddToListInput!): AddToListPayload\n  authenticateUser(input: AuthenticateUserInput!): AuthenticateUserPayload\n\n  #     Complete, or partially complete, an objective. \n  #     Objectives that must be completed multiple times will have their counter\n  #     incremented, and will become completed once the required completion count\n  #     is met.\n  #     Any achievements that become unlocked by completing this objective will\n  #     also be returned.\n  completeObjective(input: CompleteObjectiveInput!): CompleteObjectivePayload\n  createAchievement(input: CreateInput!): CreatePayload\n\n  #     Creates a new user-owned list, optionally\n  #     populated by Achievements (but can be empty initially as well)\n  createList(input: CreateListInput!): CreateListPayload\n  deleteAchievement(input: DeleteInput!): DeletePayload\n\n  #     Downvote an Achievement. If the user has already upvotes the\n  #     achievement, his/her vote will be changed.\n  downvote(input: DownvoteInput!): DownvotePayload\n\n  #       Automatically refreshes suggested Achievements by removing currently suggested Achievements (not Pinned/Favorited)\n  #       that are too far away from the current location, and repopulates the\n  # users suggested Achievements with all Achievement within range.\n  #       The User could choose to do this manually by searching for nearby\n  # achievements, or view suggested Achievements, after \n  #       this mutation is called automatically.\n  refreshSuggested(input: RefreshSuggestedInput!): RefreshSuggestedPayload\n\n  #     Declines a cooperation request by removing it. Rejected\n  #     coop requests are deleted, while accepted cooperation requests\n  #     set pending: false.\n  rejectCoop(input: RejectCoopInput!): RejectCoopPayload\n\n  #   Identifies and rejects a friend request by id. The friend request\n  #   will be deleted, so make sure to query for the friends connection\n  #   and update it on the client.\n  #   This can also be used to cancel a friend request, by rejecting\n  #   the users own (sent) friend requests.\n  rejectFriend(input: RejectFriendInput!): RejectFriendPayload\n\n  # Removes friendship with a user specified by user ID\n  removeFriend(input: RemoveFriendInput!): RemoveFriendPayload\n\n  #   Removes achievements to an existing list. User can only remove\n  #   achievements from a list if a) the user owns it or b) the\n  #   list has been shared with the user and the user has been\n  #   granted access rights.\n  removeFromList(input: RemoveFromListInput!): RemoveFromListPayload\n\n  #     Requests cooperation mode with another user, either for an entire List,\n  #     or for a single achievement\n  requestCoop(input: RequestCoopInput!): RequestCoopPayload\n\n  #   Update an Achievement with new values. A user can only update an Achievement\n  #   that he created, unless the user has sufficient permissions to update achievements\n  #   owned by somebody else.\n  updateAchievement(input: UpdateInput!): UpdatePayload\n\n  #   Update name / public status of a list\n  updateList(input: UpdateListInput!): UpdateListPayload\n\n  #   Upvote an Achievement. If the user has already downvoted the\n  #   achievement, his/her vote will be changed.\n  upvote(input: UpvoteInput!): UpvotePayload\n}\n\n# Supported OAuth providers to authenticate with\nenum OauthProvider {\n  # Authenticate with Google\n  google\n}\n\n# An objective is any one individual action that must\n# be completed in an Achievement. You could say any\n# given objective is /one/ action that has to be\n# done by the user, while an Achievement may requires\n# a user to complete /many/ actions for it to be\n# achieved.\n#\n# An example of this would be an Achievement like\n# \"Tom Waits-løpet\", that may have 20 objectives, one\n# for each pub the user must visit on that specific\n# day to have successfully completed the Achievement.\n#\n# Objectives themselves dont have any descriptions,\n# since the Objective.tagline should always be short\n# and to-the-point, and it should be clear what needs\n# to be done in a single line of text.\n#\n# ### Kinds\n# Objectives can either be location based, such as\n# visiting a place, reaching a mountain top, or in\n# general just going somewhere; or they can be action\n# oriented, like performing a dance, cooking a meal,\n# or anything else. Action oriented objectives should\n# (in the future) require some sort of verification,\n# because while we can verify that a user has gone\n# to the given coordinates, there's no way for us to\n# automatically complete objectives where a user does\n# something (unless we e.g integrate with fitness trackers).\n#\n# These kinds of objectives will require the user to\n# manually complete them by clicking \"Done\", and should\n# require uploading a photo, or similar.\n#\n# ### Time constraints\n# Objectives may be time constrained, which means they\n# can only be completed on certain days of the week, \n# certain months, or in a given time period. For example,\n# an objective for \"Visit Santa Claus at Oslo City\" may\n# only be available during December each year, while\n# \"Visit Bygdøy Beach\" may only be available between May\n# and August.\n#\n# Objective.timeConstraint defines what sort of constraint\n# should be applied using Objective.toTimestamp and\n# Objective.fromTimestamp, and may be one of:\n# - NONE: No time constraint\n# - BETWEEN_TIMESTAMP_MONTHS: Only the months (but any year)\n# - BETWEEN_TIMESTAMP_HOURS: Only the given hours (but any day)\n# - BETWEEN_TIMESTAMP_DAYS: Specific date range\n# - BETWEEN_TIMESTAMP_WEEKDAYS: Only the given weekday range, any week\n# - BETWEEN_TIMESTAMP_EXACT: Exactly this time range, down to the minute\ntype Objective {\n  # All Achievements this Objective is part of. Completing an objective may unlock multiple Achievements\n  achievements: [Achievement!]\n\n  # NOT IMPLEMENTED: Altitude to reach on these coordinates.\n  altitude: Float\n\n  # How many additional points does completing this objective yield on an Achievement?\n  basePoints: Float!\n\n  # Which country is this objective in? Normalized from coordinates.\n  country: Country\n  createdAt: Int!\n\n  # Time Constraint: From what time can this objective be completed?\n  fromTimestamp: Int\n  id: ID!\n\n  # Visible to everybody?\n  isPublic: Boolean!\n\n  # One of: ACTION, LOCATION\n  kind: String!\n\n  # Latitude to visit for location objectives - otherwise null\n  lat: Float\n\n  # Longitude to visit for location objectives - otherwise null\n  lng: Float\n\n  # How many times does the user need to do this?\n  requiredCount: Int\n\n  # A short and concise instruction of what should be done\n  tagline: String!\n\n  # Time Constraint: How should to/fromTimestamp be used?\n  timeConstraint: ObjectiveTimeConstraint\n\n  # Time Constraint: to what time can this objective be completed?\n  toTimestamp: Int\n}\n\n# The connection type for Objective.\ntype ObjectiveConnection {\n  # A list of edges.\n  edges: [ObjectiveEdge]\n\n  # Information to aid in pagination.\n  pageInfo: PageInfo!\n}\n\n# An edge in a connection.\ntype ObjectiveEdge {\n  # A cursor for use in pagination.\n  cursor: String!\n\n  # The item at the end of the edge.\n  node: Objective\n}\n\ninput ObjectiveInput {\n  basePoints: Float!\n  country: String\n  id: String\n  kind: String!\n  lat: Float\n  lng: Float\n  requiredCount: Int\n  tagline: String!\n}\n\n# ObjectiveProgress keeps track of a) if a user has completed\n# an objective and b) how many times the user has completed the\n# objective.\n# Because objectives may require the user to reach a certain number\n# of completions, there needs to be a user-oriented way to track\n# how many times an objective has been \"completed\" before its\n# actually marked as **completed**.\n# When the Objective.requiredCount (default: 1) is reached\n# for a user, the objective is considered to be completed.\ntype ObjectiveProgress {\n  # Whether or not the objective has been completed enough times\n  completed: Boolean!\n  createdAt: Int!\n  id: ID!\n\n  # The objective this progress concerns\n  objective: Objective!\n\n  # How many times the user has completed the objective\n  timesCompleted: Boolean!\n  updatedAt: Int!\n  user: User!\n}\n\nenum ObjectiveTimeConstraint {\n  # BETWEEN_TIMESTAMP_DAYS\n  BETWEEN_TIMESTAMP_DAYS\n\n  # BETWEEN_TIMESTAMP_EXACT\n  BETWEEN_TIMESTAMP_EXACT\n\n  # BETWEEN_TIMESTAMP_HOURS\n  BETWEEN_TIMESTAMP_HOURS\n\n  # BETWEEN_TIMESTAMP_MONTHS\n  BETWEEN_TIMESTAMP_MONTHS\n\n  # BETWEEN_TIMESTAMP_WEEKDAYS\n  BETWEEN_TIMESTAMP_WEEKDAYS\n\n  # NONE\n  NONE\n}\n\n# Information about pagination in a connection.\ntype PageInfo {\n  # When paginating forwards, the cursor to continue.\n  endCursor: String\n\n  # When paginating forwards, are there more items?\n  hasNextPage: Boolean!\n\n  # When paginating backwards, are there more items?\n  hasPreviousPage: Boolean!\n\n  # When paginating backwards, the cursor to continue.\n  startCursor: String\n}\n\ntype Query {\n  achievement(id: String!): Achievement\n  achievements(\n    # Returns the elements in the list that come after the specified cursor.\n    after: String\n\n    # Returns the elements in the list that come before the specified cursor.\n    before: String\n\n    # Allows you to filter by category ID\n    category: Int\n\n    # Returns the first _n_ elements from the list.\n    first: Int\n    kind: Kind\n\n    # Returns the last _n_ elements from the list.\n    last: Int\n    mode: Mode\n\n    # Whether or not to only show multiplayer Achievements\n    multiplayer: Boolean\n\n    # Provide [latitude,longitude] to search for achievements in that area\n    near: [Float!]\n\n    # ALL (public), SUGGESTED (users suggested achievements) or PERSONAL (users created achievements)\n    type: String = \"ALL\"\n  ): AchievementConnection!\n\n  # Fetch all existing Categories\n  categories(\n    # Returns the elements in the list that come after the specified cursor.\n    after: String\n\n    # Returns the elements in the list that come before the specified cursor.\n    before: String\n\n    # Returns the first _n_ elements from the list.\n    first: Int\n\n    # Returns the last _n_ elements from the list.\n    last: Int\n  ): CategoryConnection!\n  continents(\n    # Returns the elements in the list that come after the specified cursor.\n    after: String\n\n    # Returns the elements in the list that come before the specified cursor.\n    before: String\n\n    # Returns the first _n_ elements from the list.\n    first: Int\n\n    # Returns the last _n_ elements from the list.\n    last: Int\n    search: String\n  ): ContinentConnection!\n  countries(\n    # Returns the elements in the list that come after the specified cursor.\n    after: String\n\n    # Returns the elements in the list that come before the specified cursor.\n    before: String\n\n    # Returns the first _n_ elements from the list.\n    first: Int\n\n    # Returns the last _n_ elements from the list.\n    last: Int\n    search: String\n  ): CountryConnection!\n\n  # Always returns the currently logged in user. Requires authentication.\n  currentUser: User!\n\n  # Get a list of all supported icons\n  icons: [Icon!]!\n\n  # Fetch all existing kinds of Achievements\n  kinds: [Kind!]!\n\n  # Fetch all existing modes an Achievement may have\n  modes: [Mode!]!\n  objectives(\n    # Returns the elements in the list that come after the specified cursor.\n    after: String\n\n    # Returns the elements in the list that come before the specified cursor.\n    before: String\n\n    # Returns the first _n_ elements from the list.\n    first: Int\n\n    # Returns the last _n_ elements from the list.\n    last: Int\n\n    # Provide [latitude,longitude] to search for objectives in that area\n    near: [Float!]\n  ): ObjectiveConnection!\n  regions(\n    # Returns the elements in the list that come after the specified cursor.\n    after: String\n\n    # Returns the elements in the list that come before the specified cursor.\n    before: String\n\n    # Returns the first _n_ elements from the list.\n    first: Int\n\n    # Returns the last _n_ elements from the list.\n    last: Int\n    search: String\n  ): RegionConnection!\n\n  # Fetch another users data. This requires authentication.\n  user(id: String!): User!\n}\n\n# Autogenerated input type of RefreshSuggested\ninput RefreshSuggestedInput {\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n  coordinates: [Float!]\n}\n\n# Autogenerated return type of RefreshSuggested\ntype RefreshSuggestedPayload {\n  achievements: [Achievement!]\n\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n  errors: [String!]!\n}\n\ntype Region {\n  continent: Continent!\n  countries: [Country!]!\n  id: ID!\n  name: String!\n}\n\n# The connection type for Region.\ntype RegionConnection {\n  # A list of edges.\n  edges: [RegionEdge]\n\n  # Information to aid in pagination.\n  pageInfo: PageInfo!\n}\n\n# An edge in a connection.\ntype RegionEdge {\n  # A cursor for use in pagination.\n  cursor: String!\n\n  # The item at the end of the edge.\n  node: Region\n}\n\n# Autogenerated input type of RejectCoop\ninput RejectCoopInput {\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n  id: String!\n}\n\n# Autogenerated return type of RejectCoop\ntype RejectCoopPayload {\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n  coopRequest: CoopRequest\n  errors: [String!]!\n}\n\n# Autogenerated input type of RejectFriend\ninput RejectFriendInput {\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n\n  # Friend request ID to Reject\n  id: String!\n}\n\n# Autogenerated return type of RejectFriend\ntype RejectFriendPayload {\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n  errors: [String!]!\n  friend: User!\n  friendRequest: FriendRequest\n  user: User!\n}\n\n# Autogenerated input type of RemoveFriend\ninput RemoveFriendInput {\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n  userId: String!\n}\n\n# Autogenerated return type of RemoveFriend\ntype RemoveFriendPayload {\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n  errors: [String!]!\n\n  # Current user\n  user: User\n}\n\n# Autogenerated input type of RemoveFromList\ninput RemoveFromListInput {\n  # Achievements to remove\n  achievementIds: [String!]!\n\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n\n  # ID of the list to remove achievements from\n  id: String!\n}\n\n# Autogenerated return type of RemoveFromList\ntype RemoveFromListPayload {\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n  errors: [String!]!\n  list: List\n}\n\n# Autogenerated input type of RequestCoop\ninput RequestCoopInput {\n  # Achievement to request coop for\n  achievementId: String\n\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n\n  # List to request coop for\n  listId: String\n\n  # User to send request to\n  userId: String!\n}\n\n# Autogenerated return type of RequestCoop\ntype RequestCoopPayload {\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n  coopRequest: CoopRequest\n  errors: [String!]!\n}\n\ntype Role {\n  createdAt: Int!\n  id: ID!\n  name: String!\n  permissionLevel: String!\n  users: [User!]\n}\n\n# When an Achievement becomes **Unlocked**, a container is created\n# for it which adds metadata, e.g how many points were awarded for\n# completing this Achievement, and whether or not any cooperation\n# bonus points were awarded.\n#\n# This is used so that, for example, if two users are in multiplayer/coop\n# mode, and one of them is offline, the user who is online will\n# receive no coop bonus until the offline user goes online. When the\n# offline user goes online, and the Achievement becomes Unlocked\n# with a given timestamp for that user, both of their Unlocked\n# Achievement will be updated with the given coop bonus provided\n# they both unlocked the Achievement within 5 minutes of each other.\ntype Unlocked {\n  achievement: Achievement!\n\n  # Whether or not this Achievement was completed as multiplayer / coop\n  coop: Boolean!\n\n  # Additional bonus points for completing the Achievement with another user. This\n  # field will be 0 until any other users in the groups also complete the Achievement\n  coopBonus: Float!\n  createdAt: Int!\n  id: ID!\n\n  # Poins awarded for completing the Achievement, usually equals Achievement.points\n  points: Float!\n\n  # How many times a user has unlocked the same Achievement, if the Achievement can be done multiple times\n  repetitionCount: Int!\n\n  # User who unlocked this Achievement\n  user: User!\n}\n\n# The connection type for Unlocked.\ntype UnlockedConnection {\n  # A list of edges.\n  edges: [UnlockedEdge]\n\n  # Information to aid in pagination.\n  pageInfo: PageInfo!\n}\n\n# An edge in a connection.\ntype UnlockedEdge {\n  # A cursor for use in pagination.\n  cursor: String!\n\n  # The item at the end of the edge.\n  node: Unlocked\n}\n\n# Autogenerated input type of Update\ninput UpdateInput {\n  categoryId: Int!\n\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n  description: String!\n  icon: String!\n  id: String!\n  mode: Mode!\n  name: String!\n  objectives: [ObjectiveInput!]!\n}\n\n# Autogenerated input type of UpdateList\ninput UpdateListInput {\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n\n  # ID of the list to update\n  id: String!\n\n  # Whether or not this list should be visible for other users\n  isPublic: Boolean = false\n\n  # Name of the list\n  title: String!\n}\n\n# Autogenerated return type of UpdateList\ntype UpdateListPayload {\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n  errors: [String!]!\n  list: List\n}\n\n# Autogenerated return type of Update\ntype UpdatePayload {\n  achievement: Achievement\n\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n  errors: [String!]!\n}\n\n# Autogenerated input type of Upvote\ninput UpvoteInput {\n  # Achievement to upvote\n  achievementId: String!\n\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n}\n\n# Autogenerated return type of Upvote\ntype UpvotePayload {\n  achievement: Achievement\n\n  # A unique identifier for the client performing the mutation.\n  clientMutationId: String\n  errors: [String!]!\n}\n\ntype User {\n  coopPoints: Int!\n  country: Country!\n  email: String!\n  id: ID!\n  name: String!\n  personalPoints: Float!\n  points: Float!\n  role: Role!\n\n  # All Achievements unlocked by the user\n  unlockedAchievements(\n    # Returns the elements in the list that come after the specified cursor.\n    after: String\n\n    # Returns the elements in the list that come before the specified cursor.\n    before: String\n\n    # Returns the first _n_ elements from the list.\n    first: Int\n\n    # Returns the last _n_ elements from the list.\n    last: Int\n  ): UnlockedConnection!\n  unlockedCount: Int!\n\n  # All Achievements created by the user\n  userAchievements(\n    # Returns the elements in the list that come after the specified cursor.\n    after: String\n\n    # Returns the elements in the list that come before the specified cursor.\n    before: String\n\n    # Returns the first _n_ elements from the list.\n    first: Int\n\n    # Returns the last _n_ elements from the list.\n    last: Int\n  ): AchievementConnection!\n}"];
/* tslint:disable */

export interface Query {
  achievement: Achievement | null;
  achievements: AchievementConnection;
  categories: CategoryConnection;
  continents: ContinentConnection;
  countries: CountryConnection;
  currentUser: User;
  icons: Array<Icon>;
  kinds: Array<Kind>;
  modes: Array<Mode>;
  objectives: ObjectiveConnection;
  regions: RegionConnection;
  user: User;
}

export interface AchievementQueryArgs {
  id: string;
}

export interface AchievementsQueryArgs {
  after: string | null;
  before: string | null;
  category: number | null;
  first: number | null;
  kind: Kind | null;
  last: number | null;
  mode: Mode | null;
  multiplayer: boolean | null;
  near: Array<number>;
  type: string | null;
}

export interface CategoriesQueryArgs {
  after: string | null;
  before: string | null;
  first: number | null;
  last: number | null;
}

export interface ContinentsQueryArgs {
  after: string | null;
  before: string | null;
  first: number | null;
  last: number | null;
  search: string | null;
}

export interface CountriesQueryArgs {
  after: string | null;
  before: string | null;
  first: number | null;
  last: number | null;
  search: string | null;
}

export interface ObjectivesQueryArgs {
  after: string | null;
  before: string | null;
  first: number | null;
  last: number | null;
  near: Array<number>;
}

export interface RegionsQueryArgs {
  after: string | null;
  before: string | null;
  first: number | null;
  last: number | null;
  search: string | null;
}

export interface UserQueryArgs {
  id: string;
}

export interface Achievement {
  author: User;
  basePoints: number;
  category: Category;
  downvotes: number;
  expires: number | null;
  fullDescription: string | null;
  hasParents: boolean;
  icon: Icon;
  id: string;
  isGlobal: boolean;
  isMultiPlayer: boolean;
  isSuggestedGlobal: boolean;
  kind: Kind;
  mode: Mode;
  name: string;
  objectives: Array<Objective>;
  points: number;
  shortDescription: string;
  unlocked: boolean;
  upvotes: number;
}

export interface User {
  coopPoints: number;
  country: Country;
  email: string;
  id: string;
  name: string;
  personalPoints: number;
  points: number;
  role: Role;
  unlockedAchievements: UnlockedConnection;
  unlockedCount: number;
  userAchievements: AchievementConnection;
}

export interface UnlockedAchievementsUserArgs {
  after: string | null;
  before: string | null;
  first: number | null;
  last: number | null;
}

export interface UserAchievementsUserArgs {
  after: string | null;
  before: string | null;
  first: number | null;
  last: number | null;
}

export interface Country {
  id: string;
  name: string;
  region: Region;
}

export interface Region {
  continent: Continent;
  countries: Array<Country>;
  id: string;
  name: string;
}

export interface Continent {
  id: string;
  name: string;
  regions: Array<Region>;
}

export interface Role {
  createdAt: number;
  id: string;
  name: string;
  permissionLevel: string;
  users: Array<User>;
}

export interface UnlockedConnection {
  edges: Array<UnlockedEdge> | null;
  pageInfo: PageInfo;
}

export interface UnlockedEdge {
  cursor: string;
  node: Unlocked | null;
}

export interface Unlocked {
  achievement: Achievement;
  coop: boolean;
  coopBonus: number;
  createdAt: number;
  id: string;
  points: number;
  repetitionCount: number;
  user: User;
}

export interface PageInfo {
  endCursor: string | null;
  hasNextPage: boolean;
  hasPreviousPage: boolean;
  startCursor: string | null;
}

export interface AchievementConnection {
  edges: Array<AchievementEdge> | null;
  pageInfo: PageInfo;
}

export interface AchievementEdge {
  cursor: string;
  node: Achievement | null;
}

export interface Category {
  icon: string;
  id: string;
  points: number;
  title: string;
}

export type Icon = "airballoon" | "airport" | "anchor" | "anvil" | "baby_buggy" | "bank" | "barcode_scan" | "baseball" | "basketball" | "beach" | "bike" | "binoculars" | "bone" | "boombox" | "bow_tie" | "bowling" | "brain" | "bridge" | "briefcase" | "buddhism" | "bus" | "bus_clock" | "bus_double_decker" | "cake" | "cake_variant" | "camera" | "camera_iris" | "candle" | "candycane" | "car" | "car_convertible" | "car_limousine" | "caravan" | "cards" | "cards_club" | "cards_diamond" | "cards_heart" | "cards_outline" | "cards_spade" | "carrot" | "cash" | "cassette" | "castle" | "cat" | "cctv" | "ceiling_light" | "certificate" | "chess_knight" | "chili_hot" | "chili_mild" | "chip" | "christianity" | "church" | "city" | "cloud" | "coffee" | "coffee_outline" | "coffee_to_go" | "cookie" | "corn" | "cow" | "crane" | "creation" | "cube_outline" | "cube_send" | "cup" | "duck" | "dumbbell" | "earth" | "elevator" | "escalator" | "face" | "factory" | "fan" | "feather" | "fire_truck" | "fish" | "flag_variant" | "flower" | "football_helmet" | "forklift" | "fountain" | "gift" | "golf" | "gondola" | "hammer" | "hanger" | "headphones" | "hook" | "human_female" | "human_male" | "human_male_female" | "ice_cream" | "incognito" | "infinity" | "islam" | "judaism" | "key_variant" | "knife_military" | "ladybug" | "lamp" | "lead_pencil" | "leaf" | "lifebuoy" | "map_outline" | "matrix" | "motorbike" | "muffin" | "music" | "ninja" | "oil" | "owl" | "palette" | "panda" | "pickaxe" | "pier_crane" | "pig" | "pill" | "pillar" | "pine_tree" | "pipe" | "pokeball" | "poker_chip" | "pool" | "popcorn" | "qrcode_scan" | "restaurant" | "road_variant" | "rocket" | "routes" | "run" | "scale" | "scale_balance" | "seat_individual_suite" | "shower" | "sign_direction" | "snowflake" | "snowman" | "soccer" | "spray" | "stadium" | "summit" | "sunglasses" | "swim" | "sword" | "taxi" | "tennis" | "tent" | "tie" | "toilet" | "tooth" | "tractor" | "train" | "tram" | "tshirt_crew" | "van_utility" | "voice" | "watch" | "water" | "weather_sunset" | "worker" | "yin_yang";

export type Kind = "ACTION" | "DISCOVERY" | "LOCATION" | "ROUTE";

export type Mode = "DIFFICULT" | "EASY" | "EXTREME" | "NORMAL";

export interface Objective {
  achievements: Array<Achievement>;
  altitude: number | null;
  basePoints: number;
  country: Country | null;
  createdAt: number;
  fromTimestamp: number | null;
  id: string;
  isPublic: boolean;
  kind: string;
  lat: number | null;
  lng: number | null;
  requiredCount: number | null;
  tagline: string;
  timeConstraint: ObjectiveTimeConstraint | null;
  toTimestamp: number | null;
}

export type ObjectiveTimeConstraint = "BETWEEN_TIMESTAMP_DAYS" | "BETWEEN_TIMESTAMP_EXACT" | "BETWEEN_TIMESTAMP_HOURS" | "BETWEEN_TIMESTAMP_MONTHS" | "BETWEEN_TIMESTAMP_WEEKDAYS" | "NONE";

export interface CategoryConnection {
  edges: Array<CategoryEdge> | null;
  pageInfo: PageInfo;
}

export interface CategoryEdge {
  cursor: string;
  node: Category | null;
}

export interface ContinentConnection {
  edges: Array<ContinentEdge> | null;
  pageInfo: PageInfo;
}

export interface ContinentEdge {
  cursor: string;
  node: Continent | null;
}

export interface CountryConnection {
  edges: Array<CountryEdge> | null;
  pageInfo: PageInfo;
}

export interface CountryEdge {
  cursor: string;
  node: Country | null;
}

export interface ObjectiveConnection {
  edges: Array<ObjectiveEdge> | null;
  pageInfo: PageInfo;
}

export interface ObjectiveEdge {
  cursor: string;
  node: Objective | null;
}

export interface RegionConnection {
  edges: Array<RegionEdge> | null;
  pageInfo: PageInfo;
}

export interface RegionEdge {
  cursor: string;
  node: Region | null;
}

export interface Mutation {
  acceptCoop: AcceptCoopPayload | null;
  acceptFriend: AcceptFriendPayload | null;
  addFriend: AddFriendPayload | null;
  addToList: AddToListPayload | null;
  authenticateUser: AuthenticateUserPayload | null;
  completeObjective: CompleteObjectivePayload | null;
  createAchievement: CreatePayload | null;
  createList: CreateListPayload | null;
  deleteAchievement: DeletePayload | null;
  downvote: DownvotePayload | null;
  refreshSuggested: RefreshSuggestedPayload | null;
  rejectCoop: RejectCoopPayload | null;
  rejectFriend: RejectFriendPayload | null;
  removeFriend: RemoveFriendPayload | null;
  removeFromList: RemoveFromListPayload | null;
  requestCoop: RequestCoopPayload | null;
  updateAchievement: UpdatePayload | null;
  updateList: UpdateListPayload | null;
  upvote: UpvotePayload | null;
}

export interface AcceptCoopMutationArgs {
  input: AcceptCoopInput;
}

export interface AcceptFriendMutationArgs {
  input: AcceptFriendInput;
}

export interface AddFriendMutationArgs {
  input: AddFriendInput;
}

export interface AddToListMutationArgs {
  input: AddToListInput;
}

export interface AuthenticateUserMutationArgs {
  input: AuthenticateUserInput;
}

export interface CompleteObjectiveMutationArgs {
  input: CompleteObjectiveInput;
}

export interface CreateAchievementMutationArgs {
  input: CreateInput;
}

export interface CreateListMutationArgs {
  input: CreateListInput;
}

export interface DeleteAchievementMutationArgs {
  input: DeleteInput;
}

export interface DownvoteMutationArgs {
  input: DownvoteInput;
}

export interface RefreshSuggestedMutationArgs {
  input: RefreshSuggestedInput;
}

export interface RejectCoopMutationArgs {
  input: RejectCoopInput;
}

export interface RejectFriendMutationArgs {
  input: RejectFriendInput;
}

export interface RemoveFriendMutationArgs {
  input: RemoveFriendInput;
}

export interface RemoveFromListMutationArgs {
  input: RemoveFromListInput;
}

export interface RequestCoopMutationArgs {
  input: RequestCoopInput;
}

export interface UpdateAchievementMutationArgs {
  input: UpdateInput;
}

export interface UpdateListMutationArgs {
  input: UpdateListInput;
}

export interface UpvoteMutationArgs {
  input: UpvoteInput;
}

export interface AcceptCoopInput {
  clientMutationId: string | null;
  id: string;
}

export interface AcceptCoopPayload {
  clientMutationId: string | null;
  coopRequest: CoopRequest | null;
  errors: Array<string>;
}

export interface CoopRequest {
  achievement: Achievement | null;
  createdAt: number;
  id: string;
  isAccepted: boolean;
  isComplete: boolean;
  isPending: boolean;
  list: List | null;
  receiver: User;
  sender: User;
  updatedAt: number;
}

export interface List {
  achievements: Array<Achievement>;
  author: User;
  id: string;
  isPublic: boolean;
  title: string;
}

export interface AcceptFriendInput {
  clientMutationId: string | null;
  id: string;
}

export interface AcceptFriendPayload {
  clientMutationId: string | null;
  errors: Array<string>;
  friend: User;
  friendRequest: FriendRequest | null;
  user: User;
}

export interface FriendRequest {
  createdAt: number;
  id: string;
  message: string;
  receiver: User;
  sender: User;
  updatedAt: number;
}

export interface AddFriendInput {
  clientMutationId: string | null;
  message: string | null;
  userId: string;
}

export interface AddFriendPayload {
  clientMutationId: string | null;
  errors: Array<string>;
  friendRequest: FriendRequest | null;
  user: User;
}

export interface AddToListInput {
  achievementIds: Array<string>;
  clientMutationId: string | null;
  id: string;
}

export interface AddToListPayload {
  clientMutationId: string | null;
  errors: Array<string>;
  list: List | null;
}

export interface AuthenticateUserInput {
  clientMutationId: string | null;
  provider: OauthProvider;
  token: string;
}

export type OauthProvider = "google";

export interface AuthenticateUserPayload {
  clientMutationId: string | null;
  errors: Array<string>;
  user: CurrentUser | null;
}

export interface CurrentUser {
  authenticationToken: string;
  coopPoints: number;
  country: Country;
  email: string;
  id: string;
  name: string;
  personalPoints: number;
  points: number;
  role: Role;
  unlockedAchievements: UnlockedConnection;
  unlockedCount: number;
  userAchievements: AchievementConnection;
}

export interface UnlockedAchievementsCurrentUserArgs {
  after: string | null;
  before: string | null;
  first: number | null;
  last: number | null;
}

export interface UserAchievementsCurrentUserArgs {
  after: string | null;
  before: string | null;
  first: number | null;
  last: number | null;
}

export interface CompleteObjectiveInput {
  clientMutationId: string | null;
  coordinates: Array<number>;
  id: string;
  timestamp: number;
}

export interface CompleteObjectivePayload {
  clientMutationId: string | null;
  errors: Array<string>;
  objectiveProgress: ObjectiveProgress | null;
  unlockedAchievements: Array<Unlocked>;
}

export interface ObjectiveProgress {
  completed: boolean;
  createdAt: number;
  id: string;
  objective: Objective;
  timesCompleted: boolean;
  updatedAt: number;
  user: User;
}

export interface CreateInput {
  categoryId: number;
  clientMutationId: string | null;
  description: string;
  icon: Icon;
  mode: Mode;
  name: string;
  objectives: Array<ObjectiveInput>;
}

export interface ObjectiveInput {
  basePoints: number;
  country: string | null;
  id: string | null;
  kind: string;
  lat: number | null;
  lng: number | null;
  requiredCount: number | null;
  tagline: string;
}

export interface CreatePayload {
  achievement: Achievement | null;
  clientMutationId: string | null;
  errors: Array<string>;
}

export interface CreateListInput {
  achievementIds: Array<string>;
  clientMutationId: string | null;
  isPublic: boolean | null;
  title: string;
}

export interface CreateListPayload {
  clientMutationId: string | null;
  errors: Array<string>;
  list: List | null;
}

export interface DeleteInput {
  clientMutationId: string | null;
  id: string;
}

export interface DeletePayload {
  achievement: Achievement | null;
  clientMutationId: string | null;
  errors: Array<string>;
  objectives: Array<Objective>;
}

export interface DownvoteInput {
  achievementId: string;
  clientMutationId: string | null;
}

export interface DownvotePayload {
  achievement: Achievement | null;
  clientMutationId: string | null;
  errors: Array<string>;
}

export interface RefreshSuggestedInput {
  clientMutationId: string | null;
  coordinates: Array<number>;
}

export interface RefreshSuggestedPayload {
  achievements: Array<Achievement>;
  clientMutationId: string | null;
  errors: Array<string>;
}

export interface RejectCoopInput {
  clientMutationId: string | null;
  id: string;
}

export interface RejectCoopPayload {
  clientMutationId: string | null;
  coopRequest: CoopRequest | null;
  errors: Array<string>;
}

export interface RejectFriendInput {
  clientMutationId: string | null;
  id: string;
}

export interface RejectFriendPayload {
  clientMutationId: string | null;
  errors: Array<string>;
  friend: User;
  friendRequest: FriendRequest | null;
  user: User;
}

export interface RemoveFriendInput {
  clientMutationId: string | null;
  userId: string;
}

export interface RemoveFriendPayload {
  clientMutationId: string | null;
  errors: Array<string>;
  user: User | null;
}

export interface RemoveFromListInput {
  achievementIds: Array<string>;
  clientMutationId: string | null;
  id: string;
}

export interface RemoveFromListPayload {
  clientMutationId: string | null;
  errors: Array<string>;
  list: List | null;
}

export interface RequestCoopInput {
  achievementId: string | null;
  clientMutationId: string | null;
  listId: string | null;
  userId: string;
}

export interface RequestCoopPayload {
  clientMutationId: string | null;
  coopRequest: CoopRequest | null;
  errors: Array<string>;
}

export interface UpdateInput {
  categoryId: number;
  clientMutationId: string | null;
  description: string;
  icon: string;
  id: string;
  mode: Mode;
  name: string;
  objectives: Array<ObjectiveInput>;
}

export interface UpdatePayload {
  achievement: Achievement | null;
  clientMutationId: string | null;
  errors: Array<string>;
}

export interface UpdateListInput {
  clientMutationId: string | null;
  id: string;
  isPublic: boolean | null;
  title: string;
}

export interface UpdateListPayload {
  clientMutationId: string | null;
  errors: Array<string>;
  list: List | null;
}

export interface UpvoteInput {
  achievementId: string;
  clientMutationId: string | null;
}

export interface UpvotePayload {
  achievement: Achievement | null;
  clientMutationId: string | null;
  errors: Array<string>;
}
