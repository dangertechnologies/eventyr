# Autogenerated input type of AcceptCoop
input AcceptCoopInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  id: String!
}

# Autogenerated return type of AcceptCoop
type AcceptCoopPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  coopRequest: CoopRequest
  errors: [String!]!
}

# Autogenerated input type of AcceptFriend
input AcceptFriendInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # Friend request ID to accept
  id: String!
}

# Autogenerated return type of AcceptFriend
type AcceptFriendPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  errors: [String!]!
  friend: User!
  friendRequest: FriendRequest
  user: User!
}

# An Achievement is a collection of objectives
# a user must complete before having "achieved"
# something. When a user completes an Achievement,
# the points awarded are based on which Achievement.category,
# Achievement.kind, and Achievement.mode the Achievement
# had, together with the sum of all its objective's points.
#
# ### Personal vs Global
# Achievements may be personal, or global.
# When a user creates a new Achievement,
# this Achievement is always considered to be
# /personal/. This means the Achievement
# is only accessible to the user who created it,
# and any users that it has been /shared/ with,
# and so it will not show up in the normal Achievement
# search queries, but must be queried for by ID,
# or by searching specifically for a users "personal"
# Achievements. 
#
# ### Voting
# If a user wishes to make his / her Achievement
# globally accessible to everybody, he/she may set
# the flag Achievement.is_suggested_global.
# This allows the Achievement to show up as a community
# Achievement, and enables it to receive upvotes,
# or downvotes (check the mutations).
#
# It's yet to be decided what the threshold for
# upvotes/downvotes should be before an Achievement
# is made global, but it should probably be a few hundred
# upvotes, and a ratio of upvotes:downvotes of more than 3:1.
type Achievement {
  # User who created the Achievement
  author: User!

  # Achievements may have additional basePoints used to calculate Achievement.points
  basePoints: Int!

  # Category the Achievement belongs to, e.g Food & Culinary, Culture, etc.
  category: Category!

  # Other users the user is currently cooperating with on this Achievement
  cooperationUsers: [User!]
  downvotes: Int!
  expires: Int

  # Entire description. This may be very long.
  fullDescription: String

  # Does this Achievement depend on other Achievements? (BETA)
  hasParents: Boolean!

  # An icon from the specified subset of MaterialCommunityIcons
  icon: Icon!
  id: ID!

  # User's lists that contain this Achievement
  inLists: [List!]!

  # Whether or not the Achievement is available to everybody
  isGlobal: Boolean!

  # Does this Achievement allow users to complete it as a group? Default: true
  isMultiPlayer: Boolean!

  # Has the owner suggested this Achievement to be evaluated by the community?
  isSuggestedGlobal: Boolean!

  # Achievement type, e.g ACTION, DISCOVERY, LOCATION, ROUTE
  kind: Kind!

  # Difficulty. One of: DIFFICULT, EASY, EXTREME, NORMAL
  mode: Mode!
  name: String!

  # All linked Objectives. Objectives may belong to multiple Achievements.
  objectives: [Objective!]!

  # Calculated points awarded for completing the Achievement
  points: Float!

  # Ellipsized first 100 characters of the description, before the first newline
  shortDescription: String!

  # Whether or not the user has unlocked this Achievement
  unlocked: Boolean!
  upvotes: Int!
}

# The connection type for Achievement.
type AchievementConnection {
  # A list of edges.
  edges: [AchievementEdge]

  # A list of nodes.
  nodes: [Achievement]

  # Information to aid in pagination.
  pageInfo: PageInfo!
}

# An edge in a connection.
type AchievementEdge {
  # A cursor for use in pagination.
  cursor: String!

  # The item at the end of the edge.
  node: Achievement
}

# Autogenerated input type of AddFriend
input AddFriendInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  message: String

  # User to send a friend request to
  userIds: [String!]!
}

# Autogenerated return type of AddFriend
type AddFriendPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  errors: [String!]!
  friendRequests: [FriendRequest!]
  user: User!
}

# Autogenerated input type of AddToList
input AddToListInput {
  achievementIds: [String!]!

  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # ID of the list to add achievements to
  listIds: [String!]!
}

# Autogenerated return type of AddToList
type AddToListPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  errors: [String!]!
  lists: [List!]
}

# Autogenerated input type of AuthenticateUser
input AuthenticateUserInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  provider: OauthProvider!
  token: String!
}

# Autogenerated return type of AuthenticateUser
type AuthenticateUserPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  errors: [String!]!
  user: CurrentUser
}

type Category {
  icon: String!
  id: ID!
  points: Int!
  title: String!
}

# The connection type for Category.
type CategoryConnection {
  # A list of edges.
  edges: [CategoryEdge]

  # A list of nodes.
  nodes: [Category]

  # Information to aid in pagination.
  pageInfo: PageInfo!
}

# An edge in a connection.
type CategoryEdge {
  # A cursor for use in pagination.
  cursor: String!

  # The item at the end of the edge.
  node: Category
}

# Autogenerated input type of CompleteObjective
input CompleteObjectiveInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  coordinates: [Float!]
  id: String!
  timestamp: Int!
}

# Autogenerated return type of CompleteObjective
type CompleteObjectivePayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  errors: [String!]!
  objectiveProgress: ObjectiveProgress
  unlockedAchievements: [Unlocked!]
}

type Continent {
  id: ID!
  name: String!
  regions: [Region!]!
}

# The connection type for Continent.
type ContinentConnection {
  # A list of edges.
  edges: [ContinentEdge]

  # A list of nodes.
  nodes: [Continent]

  # Information to aid in pagination.
  pageInfo: PageInfo!
}

# An edge in a connection.
type ContinentEdge {
  # A cursor for use in pagination.
  cursor: String!

  # The item at the end of the edge.
  node: Continent
}

# Cooperation Requests can be sent from any Achievement,
# to any other user in the area, to ask whether or not they
# would like to meet up and complete the Achievement together.
# When a CoopRequest is sent, the user may receive a notification
# like 'Annie has invited you to complete an Achievement',
# and once the other party has accepted the invitation, both users
# are now in *coop mode* for this Achievement, and will receive
# bonus points for completing it.
#
# Cooperation Requests can also be sent for *lists*, which binds
# users to receive a coop bonus for any of the Achievements in the
# list, provided they complete the Achievement within 5 minutes of
# eachother. It doesn't matter if one of the users is without internet
# connection or not, because as soon as he/she connects and unlocks
# the Achievement, both will be awarded bonus points.
#
# ### Bonus calculation
# Coop bonus is calculated as: `Achievement.points * 0.8^N`,
# where N is the amount of times users have cooperated together
# before, but never goes below 3. This means that each time you
# complete an Achievement with somebody, you get +80% extra points,
# and the next time you complete an Achievement with the same person,
# you get 80% of those 80% extra points, and so on. This causes
# *diminishing returns*, where it will **always** be beneficial
# for you to complete Achievements with other people, but it will
# always be *more* beneficial to complete Achievements with new people.
#
# ### Groups
# Lets say Annie and her boyfriend Barry always go together, but have
# decided to meet up with a new third person, Claire. 
# If the user is in multiplayer/cooperation mode with **several** users,
# the coop bonus **does not compound**. Annie **will not** receive +80%
# for cooperating with Claire and another bonus for Barry. 
# Instead, the users **always gets the highest coop bonus available to them**.
#
# This incentivizes inviting new people, because even if you always
# unlock Achievements with a friend, inviting at least one new person
# everytime, ensures everybody gets an additional 80% extra points.
#
# ### Practicality
# TODO: When a user accepts a CoopRequest, we should perhaps provide a
# time and location for them to meet up, but without knowing either users
# location, this is difficult. Instead, we may need to introduce a way for
# users to either a) message eachother or b) agree on a meetup point.
type CoopRequest implements NotificationInterface {
  # Achievement the coop request applies to. May be null if a list is given
  achievement: Achievement
  createdAt: Int!
  id: ID!

  # Has the receiving user accepted the request?
  isAccepted: Boolean!

  # When the request is accepted, and the objective has been completed for both users, this will be true
  isComplete: Boolean!

  # CoopRequest is pending until the receiving user accepts it
  isPending: Boolean!

  # List the coop request applies to. May be null if an Achievement is given.
  list: List

  # Message to the receiver
  message: String!

  # User who received this request
  receiver: User!

  # User who sent this request
  sender: User!
  updatedAt: Int!
}

type Country {
  id: ID!
  name: String!
  region: Region!
}

# The connection type for Country.
type CountryConnection {
  # A list of edges.
  edges: [CountryEdge]

  # A list of nodes.
  nodes: [Country]

  # Information to aid in pagination.
  pageInfo: PageInfo!
}

# An edge in a connection.
type CountryEdge {
  # A cursor for use in pagination.
  cursor: String!

  # The item at the end of the edge.
  node: Country
}

# Autogenerated input type of Create
input CreateInput {
  categoryId: Int!

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  description: String!
  icon: Icon!
  mode: Mode!
  name: String!
  objectives: [ObjectiveInput!]!
}

# Autogenerated input type of CreateList
input CreateListInput {
  # List of Achievement IDs to add to the list
  achievementIds: [String!]

  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # Whether or not this list should be visible for other users
  isPublic: Boolean = false

  # Name of the list
  title: String!
}

# Autogenerated return type of CreateList
type CreateListPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  errors: [String!]!
  list: List
}

# Autogenerated return type of Create
type CreatePayload {
  achievement: Achievement

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  errors: [String!]!
}

#       Same as UserType, but always contains a new authenticationToken
#       the user may use to authenticate.
#
#       TODO: Cache this token, instead of generating a new one on every request.
type CurrentUser {
  allowCoop: Boolean!
  authenticationToken: String!
  avatar: String
  coopPoints: Int!
  country: Country!
  email: String!
  id: ID!
  isFriend: Boolean!
  isPendingFriend: Boolean!

  # User's created lists
  lists(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the first _n_ elements from the list.
    first: Int

    # Returns the last _n_ elements from the list.
    last: Int
  ): ListConnection!
  name: String!
  personalPoints: Float!
  points: Float!
  role: Role!

  # All Achievements unlocked by the user
  unlockedAchievements(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the first _n_ elements from the list.
    first: Int

    # Returns the last _n_ elements from the list.
    last: Int
  ): UnlockedConnection!
  unlockedCount: Int!

  # All Achievements created by the user
  userAchievements(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the first _n_ elements from the list.
    first: Int

    # Returns the last _n_ elements from the list.
    last: Int
  ): AchievementConnection!
}

# Autogenerated input type of Delete
input DeleteInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  id: String!
}

# Autogenerated return type of Delete
type DeletePayload {
  achievement: Achievement

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  errors: [String!]!
  objectives: [Objective!]
}

# Autogenerated input type of Downvote
input DownvoteInput {
  # Achievement to downvote
  achievementId: String!

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
}

# Autogenerated return type of Downvote
type DownvotePayload {
  achievement: Achievement

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  errors: [String!]!
}

# Autogenerated input type of FollowList
input FollowListInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # List to follow
  listId: String
}

# Autogenerated return type of FollowList
type FollowListPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  errors: [String!]!
  list: List
}

# Friend requests lets users add other users as their friends,
# and the main purpose of this is so that when a user links
# their account with a social network, if he/she allows us to
# import their friends, we can find (or suggest) friends to
# add.
#
# We use a Friend-model rather than a Follow-model so that
# if we were to display recently completed Achievements by
# friends on the Home-screen, the user must have explicitly
# accepted the people who would see their unlocked Achievements
# in their feed; whereas with a Follow-model, anybody could
# keep track of the physical whereabouts of anybody else, at
# any given time. Even if we do not track anybody's location,
# seeing that somebody unlocked an Achievement near e.g the
# Eiffel tower 5 minutes ago, gives you a pretty good idea that
# they must be somewhere around the Eiffel tower.
#
# Because we consider this sensitive user information, users
# must explicitly add, and accept, who is allowed to see when
# they complete Achievements.
type FriendRequest implements NotificationInterface {
  createdAt: Int!
  id: ID!

  # Whether or not this request has been accepted
  isAccepted: Boolean!

  # Add a message to the user you're sending a request to
  message: String!

  # User who will receive the request
  receiver: User!

  # User who sent the request
  sender: User!
  updatedAt: Int!
}

#   Subset of MaterialCommunityIcons
enum Icon {
  # airballoon
  airballoon

  # airport
  airport

  # anchor
  anchor

  # anvil
  anvil

  # baby-buggy
  baby_buggy

  # bank
  bank

  # barcode-scan
  barcode_scan

  # baseball
  baseball

  # basketball
  basketball

  # beach
  beach

  # bike
  bike

  # binoculars
  binoculars

  # bone
  bone

  # boombox
  boombox

  # bow-tie
  bow_tie

  # bowling
  bowling

  # brain
  brain

  # bridge
  bridge

  # briefcase
  briefcase

  # buddhism
  buddhism

  # bus
  bus

  # bus-clock
  bus_clock

  # bus-double-decker
  bus_double_decker

  # cake
  cake

  # cake-variant
  cake_variant

  # camera
  camera

  # camera-iris
  camera_iris

  # candle
  candle

  # candycane
  candycane

  # car
  car

  # car-convertible
  car_convertible

  # car-limousine
  car_limousine

  # caravan
  caravan

  # cards
  cards

  # cards-club
  cards_club

  # cards-diamond
  cards_diamond

  # cards-heart
  cards_heart

  # cards-outline
  cards_outline

  # cards-spade
  cards_spade

  # carrot
  carrot

  # cash
  cash

  # cassette
  cassette

  # castle
  castle

  # cat
  cat

  # cctv
  cctv

  # ceiling-light
  ceiling_light

  # certificate
  certificate

  # chess-knight
  chess_knight

  # chili-hot
  chili_hot

  # chili-mild
  chili_mild

  # chip
  chip

  # christianity
  christianity

  # church
  church

  # city
  city

  # cloud
  cloud

  # coffee
  coffee

  # coffee-outline
  coffee_outline

  # coffee-to-go
  coffee_to_go

  # cookie
  cookie

  # corn
  corn

  # cow
  cow

  # crane
  crane

  # creation
  creation

  # cube-outline
  cube_outline

  # cube-send
  cube_send

  # cup
  cup

  # duck
  duck

  # dumbbell
  dumbbell

  # earth
  earth

  # elevator
  elevator

  # escalator
  escalator

  # face
  face

  # factory
  factory

  # fan
  fan

  # feather
  feather

  # fire-truck
  fire_truck

  # fish
  fish

  # flag-variant
  flag_variant

  # flower
  flower

  # football-helmet
  football_helmet

  # forklift
  forklift

  # fountain
  fountain

  # gift
  gift

  # golf
  golf

  # gondola
  gondola

  # hammer
  hammer

  # hanger
  hanger

  # headphones
  headphones

  # hook
  hook

  # human-female
  human_female

  # human-male
  human_male

  # human-male-female
  human_male_female

  # ice-cream
  ice_cream

  # incognito
  incognito

  # infinity
  infinity

  # islam
  islam

  # judaism
  judaism

  # key-variant
  key_variant

  # knife-military
  knife_military

  # ladybug
  ladybug

  # lamp
  lamp

  # lead-pencil
  lead_pencil

  # leaf
  leaf

  # lifebuoy
  lifebuoy

  # map-outline
  map_outline

  # matrix
  matrix

  # motorbike
  motorbike

  # muffin
  muffin

  # music
  music

  # ninja
  ninja

  # oil
  oil

  # owl
  owl

  # palette
  palette

  # panda
  panda

  # pickaxe
  pickaxe

  # pier-crane
  pier_crane

  # pig
  pig

  # pill
  pill

  # pillar
  pillar

  # pine-tree
  pine_tree

  # pipe
  pipe

  # pokeball
  pokeball

  # poker-chip
  poker_chip

  # pool
  pool

  # popcorn
  popcorn

  # qrcode-scan
  qrcode_scan

  # restaurant
  restaurant

  # road-variant
  road_variant

  # rocket
  rocket

  # routes
  routes

  # run
  run

  # scale
  scale

  # scale-balance
  scale_balance

  # seat-individual-suite
  seat_individual_suite

  # shower
  shower

  # sign-direction
  sign_direction

  # snowflake
  snowflake

  # snowman
  snowman

  # soccer
  soccer

  # spray
  spray

  # stadium
  stadium

  # summit
  summit

  # sunglasses
  sunglasses

  # swim
  swim

  # sword
  sword

  # taxi
  taxi

  # tennis
  tennis

  # tent
  tent

  # tie
  tie

  # toilet
  toilet

  # tooth
  tooth

  # tractor
  tractor

  # train
  train

  # tram
  tram

  # tshirt-crew
  tshirt_crew

  # van-utility
  van_utility

  # voice
  voice

  # watch
  watch

  # water
  water

  # weather-sunset
  weather_sunset

  # worker
  worker

  # yin-yang
  yin_yang
}

enum Kind {
  # 25
  ACTION

  # 35
  DISCOVERY

  # 15
  LOCATION

  # 50
  ROUTE
}

# Lists are containers for Achievements, designed
# to let users, or the community, curate collections
# of Achievements to complete for special purposes. 
# On a community scale, a List of Achievements could 
# be something like "Winter is coming", and contain
# a set of winter-specific Achievements to complete.
#
# For users, it's important to be able to curate
# their own lists, to easily be able to share a set
# of custom Achievements to be completed with friends.
# For example, if you were going on a hiking trip with
# a group of friends, you may want to create a list
# called *Hiking the Alps*, which could contain some
# of the public Achievements in the alps, and maybe
# some Achievements you've created yourself. Since
# Achievements you've created yourself are only
# accessible to the users you've shared it with,
# putting them in a list and then sharing the list
# is a quick and easy way to share multiple Achievements
# and allow friends to complete non-public Achievements
# together with you.
type List {
  # Contents of the list. Can be updated by everybody the list has been shared with, and the author.
  achievements(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the first _n_ elements from the list.
    first: Int

    # Returns the last _n_ elements from the list.
    last: Int
  ): AchievementConnection

  # Total number of Achievements available in list
  achievementsCount: Int!

  # User who created this list
  author: User!

  # Coordinates for all objectives in all Achievements in list. This can be used
  # to sort lists by distance (of the closest Achievement)
  coordinates: [[Float!]!]!
  id: ID!
  isEditable: Boolean!

  # Whether or not the user is following this list
  isFollowed: Boolean!

  # Whether or not this list is available to everybody
  isPublic: Boolean!

  # Name of the list
  title: String!
}

# The connection type for List.
type ListConnection {
  # A list of edges.
  edges: [ListEdge]

  # A list of nodes.
  nodes: [List]

  # Information to aid in pagination.
  pageInfo: PageInfo!
}

# An edge in a connection.
type ListEdge {
  # A cursor for use in pagination.
  cursor: String!

  # The item at the end of the edge.
  node: List
}

enum Mode {
  # 15
  DIFFICULT

  # 5
  EASY

  # 20
  EXTREME

  # 10
  NORMAL
}

type Mutation {
  #   Accepts a cooperation request by setting pending: false. Rejected
  #   coop requests are deleted, so if a coop request has pending: false,
  #   it's an active cooperation link between two users
  acceptCoop(input: AcceptCoopInput!): AcceptCoopPayload

  #     Identifies and accepts a friend request by id. The friend request
  #     will be deleted, and the sender will be added to the user's friends.
  #     Make sure to query for the friends connection, or the friend field,
  #     and update the connection on the client.
  acceptFriend(input: AcceptFriendInput!): AcceptFriendPayload

  #   Identifies and adds a friend request by id. The friend request
  #   will be deleted, and the sender will be added to the user's friends.
  #   Make sure to query for the friends connection, or the friend field,
  #   and update the connection on the client.
  addFriend(input: AddFriendInput!): AddFriendPayload

  #   Adds achievements to an existing list. User can only add
  #   achievements to a list if a) the user owns it or b) the
  #   list has been shared with the user and the user has been
  #   granted access rights.
  addToList(input: AddToListInput!): AddToListPayload
  authenticateUser(input: AuthenticateUserInput!): AuthenticateUserPayload

  #     Complete, or partially complete, an objective. 
  #     Objectives that must be completed multiple times will have their counter
  #     incremented, and will become completed once the required completion count
  #     is met.
  #     Any achievements that become unlocked by completing this objective will
  #     also be returned.
  completeObjective(input: CompleteObjectiveInput!): CompleteObjectivePayload
  createAchievement(input: CreateInput!): CreatePayload

  #     Creates a new user-owned list, optionally
  #     populated by Achievements (but can be empty initially as well)
  createList(input: CreateListInput!): CreateListPayload
  deleteAchievement(input: DeleteInput!): DeletePayload

  #     Downvote an Achievement. If the user has already upvotes the
  #     achievement, his/her vote will be changed.
  downvote(input: DownvoteInput!): DownvotePayload

  #   Follow another users list, making it show up when querying for
  #   current users lists, but with another author.
  followList(input: FollowListInput!): FollowListPayload

  #       Automatically refreshes suggested Achievements by removing currently suggested Achievements (not Pinned/Favorited)
  #       that are too far away from the current location, and repopulates the
  # users suggested Achievements with all Achievement within range.
  #       The User could choose to do this manually by searching for nearby
  # achievements, or view suggested Achievements, after 
  #       this mutation is called automatically.
  refreshSuggested(input: RefreshSuggestedInput!): RefreshSuggestedPayload

  #   Declines a cooperation request by removing it. Rejected
  #   coop requests are deleted, while accepted cooperation requests
  #   set pending: false.
  rejectCoop(input: RejectCoopInput!): RejectCoopPayload

  #   Identifies and rejects a friend request by id. The friend request
  #   will be deleted, so make sure to query for the friends connection
  #   and update it on the client.
  #   This can also be used to cancel a friend request, by rejecting
  #   the users own (sent) friend requests.
  rejectFriend(input: RejectFriendInput!): RejectFriendPayload

  #   Identifies and rejects a list share request by id. The share request
  #   will be deleted, so make sure to query for the connection
  #   and update it on the client.
  rejectList(input: RejectListInput!): RejectListPayload

  # Removes friendship with a user specified by user ID
  removeFriend(input: RemoveFriendInput!): RemoveFriendPayload

  #   Removes achievements to an existing list. User can only remove
  #   achievements from a list if a) the user owns it or b) the
  #   list has been shared with the user and the user has been
  #   granted access rights.
  removeFromList(input: RemoveFromListInput!): RemoveFromListPayload

  #   Requests cooperation mode with another user, either for an entire List,
  #   or for a single achievement
  requestCoop(input: RequestCoopInput!): RequestCoopPayload

  #   Shares an Achievement with a user. If the Achievement is a private
  #   Achievement, the receiving user will be granted access to it,
  #   allowing it to appear in their feed, and letting them complete it.
  shareAchievement(input: ShareAchievementInput!): ShareAchievementPayload

  #   Shares an Achievement with a user. If the Achievement is a private
  #   Achievement, the receiving user will be granted access to it,
  #   allowing it to appear in their feed, and letting them complete it.
  shareList(input: ShareListInput!): ShareListPayload

  #   Update an Achievement with new values. A user can only update an Achievement
  #   that he created, unless the user has sufficient permissions to update achievements
  #   owned by somebody else.
  updateAchievement(input: UpdateInput!): UpdatePayload

  #   Update name / public status of a list
  updateList(input: UpdateListInput!): UpdateListPayload
  updateMe(input: UpdateMeInput!): UpdateMePayload

  #   Upvote an Achievement. If the user has already downvoted the
  #   achievement, his/her vote will be changed.
  upvote(input: UpvoteInput!): UpvotePayload
}

# **IMPORTANT**: These are not necessarily PUSH notifications,
# but notifications that may show up in a users "feed",
# or in-app notification list.
#
# A Notification could be anything like:
# - "Annie has invited you to cooperate on View from the Top"
# - "Claire sent you a friend request"
# - "Achievement Unlocked: DoubleDutch Dinosaur Duplex in Dubai"
# - "Dirk accepted your cooperation request."
# - "Erin added a new item to your list Hiking the Pyrenees"
# - "Fred unlocked Stormy Seas! +375 coop bonus"
# - "Gerardo shared a List with you."
#
# Some notifications may require an action from the user, and
# some may just be informational. It's up to the client to decide
# whether an action should be required of, or offered to the user.
#
# If a notification involves another user, such as when the notification
# is a FriendRequest, or CoopRequest, this user will be set as Notification.sender,
# and the resource it concerns, e.g a CoopRequest, will be set as the
# Notification.target
#
# Messages displayed for notifications are up to the client, to allow
# proper localization.
type Notification {
  createdAt: Int!
  id: ID!
  kind: NotificationKind!

  # User receiving the notification
  receiver: User!

  # Whether or not the user has seen this notification. Will be set to `true` when the receiving user receives it.
  seen: Boolean!

  # User sending the notification, if any
  sender: User

  # Resource to perform additional actions upon, e.g a CoopRequest to accept/reject
  target: NotificationInterface!

  # String representation of the target model, e.g CoopRequest, Unlocked, etc.
  targetType: String!
}

# The connection type for Notification.
type NotificationConnection {
  # A list of edges.
  edges: [NotificationEdge]

  # A list of nodes.
  nodes: [Notification]

  # Information to aid in pagination.
  pageInfo: PageInfo!
}

# An edge in a connection.
type NotificationEdge {
  # A cursor for use in pagination.
  cursor: String!

  # The item at the end of the edge.
  node: Notification
}

interface NotificationInterface {
  id: ID!
}

enum NotificationKind {
  # 0
  ACHIEVEMENT_UNLOCKED

  # 1
  ACHIEVEMENT_UNLOCKED_COOP_BONUS

  # 3
  COOPERATION_REQUEST_ACCEPTED

  # 2
  COOPERATION_REQUEST_RECEIVED

  # 4
  COOPERATION_REQUEST_REJECTED

  # 8
  FRIEND_REQUEST_ACCEPTED

  # 7
  FRIEND_REQUEST_RECEIVED

  # 9
  REWARD_UNLOCKED

  # 5
  SHARED_ACHIEVEMENT_RECEIVED

  # 6
  SHARED_LIST_RECEIVED
}

# Supported OAuth providers to authenticate with
enum OauthProvider {
  # Demo user used by TestFlight only.
  demo

  # Authenticate with Google
  google
}

# An objective is any one individual action that must
# be completed in an Achievement. You could say any
# given objective is /one/ action that has to be
# done by the user, while an Achievement may requires
# a user to complete /many/ actions for it to be
# achieved.
#
# An example of this would be an Achievement like
# "Tom Waits-løpet", that may have 20 objectives, one
# for each pub the user must visit on that specific
# day to have successfully completed the Achievement.
#
# Objectives themselves dont have any descriptions,
# since the Objective.tagline should always be short
# and to-the-point, and it should be clear what needs
# to be done in a single line of text.
#
# ### Kinds
# Objectives can either be location based, such as
# visiting a place, reaching a mountain top, or in
# general just going somewhere; or they can be action
# oriented, like performing a dance, cooking a meal,
# or anything else. Action oriented objectives should
# (in the future) require some sort of verification,
# because while we can verify that a user has gone
# to the given coordinates, there's no way for us to
# automatically complete objectives where a user does
# something (unless we e.g integrate with fitness trackers).
#
# These kinds of objectives will require the user to
# manually complete them by clicking "Done", and should
# require uploading a photo, or similar.
#
# ### Time constraints
# Objectives may be time constrained, which means they
# can only be completed on certain days of the week, 
# certain months, or in a given time period. For example,
# an objective for "Visit Santa Claus at Oslo City" may
# only be available during December each year, while
# "Visit Bygdøy Beach" may only be available between May
# and August.
#
# Objective.timeConstraint defines what sort of constraint
# should be applied using Objective.toTimestamp and
# Objective.fromTimestamp, and may be one of:
# - NONE: No time constraint
# - BETWEEN_TIMESTAMP_MONTHS: Only the months (but any year)
# - BETWEEN_TIMESTAMP_HOURS: Only the given hours (but any day)
# - BETWEEN_TIMESTAMP_DAYS: Specific date range
# - BETWEEN_TIMESTAMP_WEEKDAYS: Only the given weekday range, any week
# - BETWEEN_TIMESTAMP_EXACT: Exactly this time range, down to the minute
type Objective {
  # All Achievements this Objective is part of. Completing an objective may unlock multiple Achievements
  achievements: [Achievement!]

  # NOT IMPLEMENTED: Altitude to reach on these coordinates.
  altitude: Float

  # How many additional points does completing this objective yield on an Achievement?
  basePoints: Float!

  # Which country is this objective in? Normalized from coordinates.
  country: Country
  createdAt: Int!

  # Time Constraint: From what time can this objective be completed?
  fromTimestamp: Int
  id: ID!

  # Visible to everybody?
  isPublic: Boolean!

  # One of: ACTION, LOCATION
  kind: String!

  # Latitude to visit for location objectives - otherwise null
  lat: Float

  # Longitude to visit for location objectives - otherwise null
  lng: Float

  # How many times does the user need to do this?
  requiredCount: Int

  # A short and concise instruction of what should be done
  tagline: String!

  # Time Constraint: How should to/fromTimestamp be used?
  timeConstraint: ObjectiveTimeConstraint

  # Time Constraint: to what time can this objective be completed?
  toTimestamp: Int
}

# The connection type for Objective.
type ObjectiveConnection {
  # A list of edges.
  edges: [ObjectiveEdge]

  # A list of nodes.
  nodes: [Objective]

  # Information to aid in pagination.
  pageInfo: PageInfo!
}

# An edge in a connection.
type ObjectiveEdge {
  # A cursor for use in pagination.
  cursor: String!

  # The item at the end of the edge.
  node: Objective
}

input ObjectiveInput {
  basePoints: Float!
  country: String
  id: String
  kind: String!
  lat: Float
  lng: Float
  requiredCount: Int
  tagline: String!
}

# ObjectiveProgress keeps track of a) if a user has completed
# an objective and b) how many times the user has completed the
# objective.
# Because objectives may require the user to reach a certain number
# of completions, there needs to be a user-oriented way to track
# how many times an objective has been "completed" before its
# actually marked as **completed**.
# When the Objective.requiredCount (default: 1) is reached
# for a user, the objective is considered to be completed.
type ObjectiveProgress {
  # Whether or not the objective has been completed enough times
  completed: Boolean!
  createdAt: Int!
  id: ID!

  # The objective this progress concerns
  objective: Objective!

  # How many times the user has completed the objective
  timesCompleted: Boolean!
  updatedAt: Int!
  user: User!
}

enum ObjectiveTimeConstraint {
  # BETWEEN_TIMESTAMP_DAYS
  BETWEEN_TIMESTAMP_DAYS

  # BETWEEN_TIMESTAMP_EXACT
  BETWEEN_TIMESTAMP_EXACT

  # BETWEEN_TIMESTAMP_HOURS
  BETWEEN_TIMESTAMP_HOURS

  # BETWEEN_TIMESTAMP_MONTHS
  BETWEEN_TIMESTAMP_MONTHS

  # BETWEEN_TIMESTAMP_WEEKDAYS
  BETWEEN_TIMESTAMP_WEEKDAYS

  # NONE
  NONE
}

# Information about pagination in a connection.
type PageInfo {
  # When paginating forwards, the cursor to continue.
  endCursor: String

  # When paginating forwards, are there more items?
  hasNextPage: Boolean!

  # When paginating backwards, are there more items?
  hasPreviousPage: Boolean!

  # When paginating backwards, the cursor to continue.
  startCursor: String
}

type Query {
  achievement(id: String!): Achievement
  achievements(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Allows you to filter by category ID
    category: Int

    # Order by distance from these coordinates
    coordinates: [Float!]

    # Returns the first _n_ elements from the list.
    first: Int
    kind: Kind

    # Returns the last _n_ elements from the list.
    last: Int

    # Fetch all Achievements belonging to a list
    listId: String
    mode: Mode

    # Whether or not to only show multiplayer Achievements
    multiplayer: Boolean

    # Provide [latitude,longitude] to search for achievements in that area
    near: [Float!]

    # ALL (public), SUGGESTED (users suggested achievements), COMMUNITY, or PERSONAL (users created achievements)
    type: String = "ALL"
  ): AchievementConnection!

  # Fetch all existing Categories
  categories(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the first _n_ elements from the list.
    first: Int

    # Returns the last _n_ elements from the list.
    last: Int
  ): CategoryConnection!
  continents(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the first _n_ elements from the list.
    first: Int

    # Returns the last _n_ elements from the list.
    last: Int
    search: String
  ): ContinentConnection!
  countries(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the first _n_ elements from the list.
    first: Int

    # Returns the last _n_ elements from the list.
    last: Int
    search: String
  ): CountryConnection!

  # Always returns the currently logged in user. Requires authentication.
  currentUser: User!
  followedLists(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the first _n_ elements from the list.
    first: Int

    # Returns the last _n_ elements from the list.
    last: Int
  ): ListConnection!

  # Find friends of current user
  friends(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the first _n_ elements from the list.
    first: Int

    # Returns the last _n_ elements from the list.
    last: Int

    # Search for users matching exact email or name
    search: String
  ): UserConnection!

  # Get a list of all supported icons
  icons: [Icon!]!

  # Fetch all existing kinds of Achievements
  kinds: [Kind!]!
  lists(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the first _n_ elements from the list.
    first: Int

    # Returns the last _n_ elements from the list.
    last: Int

    # Find lists with Achievements in the nearby area. This can be used to show lists in the feed
    near: [Float!]

    # Used to determine what kind of Achievements to search for, same as the type field on Achievements
    type: String
    userId: String
  ): ListConnection!

  # Fetch all existing modes an Achievement may have
  modes: [Mode!]!

  # Notifications received by the user
  notifications(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the first _n_ elements from the list.
    first: Int

    # Returns the last _n_ elements from the list.
    last: Int
  ): NotificationConnection!
  objectives(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the first _n_ elements from the list.
    first: Int

    # Returns the last _n_ elements from the list.
    last: Int

    # Provide [latitude,longitude] to search for objectives in that area
    near: [Float!]
  ): ObjectiveConnection!
  regions(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the first _n_ elements from the list.
    first: Int

    # Returns the last _n_ elements from the list.
    last: Int
    search: String
  ): RegionConnection!

  # Fetch another users data. This requires authentication.
  user(id: String!): User!

  # Find users currently working on the same achievements, or search for users by
  # name or email. At least one argument is required.
  users(
    # Find users currently working on this Achievement
    achievementId: String

    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the first _n_ elements from the list.
    first: Int

    # Returns the last _n_ elements from the list.
    last: Int

    # Search for users by email or name. The match must be /exact/, for privacy reasons.
    search: String
  ): UserConnection!
}

# Autogenerated input type of RefreshSuggested
input RefreshSuggestedInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  coordinates: [Float!]
}

# Autogenerated return type of RefreshSuggested
type RefreshSuggestedPayload {
  achievements(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the first _n_ elements from the list.
    first: Int

    # Returns the last _n_ elements from the list.
    last: Int
  ): AchievementConnection

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  errors: [String!]!
}

type Region {
  continent: Continent!
  countries: [Country!]!
  id: ID!
  name: String!
}

# The connection type for Region.
type RegionConnection {
  # A list of edges.
  edges: [RegionEdge]

  # A list of nodes.
  nodes: [Region]

  # Information to aid in pagination.
  pageInfo: PageInfo!
}

# An edge in a connection.
type RegionEdge {
  # A cursor for use in pagination.
  cursor: String!

  # The item at the end of the edge.
  node: Region
}

# Autogenerated input type of RejectCoop
input RejectCoopInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  id: String!
}

# Autogenerated return type of RejectCoop
type RejectCoopPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  coopRequest: CoopRequest
  errors: [String!]!
}

# Autogenerated input type of RejectFriend
input RejectFriendInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # Friend request ID to Reject
  id: String!
}

# Autogenerated return type of RejectFriend
type RejectFriendPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  errors: [String!]!
  friend: User!
  friendRequest: FriendRequest
  user: User!
}

# Autogenerated input type of RejectList
input RejectListInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # SharedList request ID to Reject
  id: String!
}

# Autogenerated return type of RejectList
type RejectListPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  errors: [String!]!
  shareRequest: SharedList
}

# Autogenerated input type of RemoveFriend
input RemoveFriendInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  userId: String!
}

# Autogenerated return type of RemoveFriend
type RemoveFriendPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  errors: [String!]!

  # Current user
  user: User
}

# Autogenerated input type of RemoveFromList
input RemoveFromListInput {
  # Achievements to remove
  achievementIds: [String!]!

  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # ID of the list to remove achievements from
  listId: String!
}

# Autogenerated return type of RemoveFromList
type RemoveFromListPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  errors: [String!]!
  list: List
  removedIds: [String!]
}

# Autogenerated input type of RequestCoop
input RequestCoopInput {
  # Achievement to request coop for
  achievementId: String

  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # List to request coop for
  listId: String

  # Message to show the receiving user
  message: String!

  # User to send request to
  userIds: [String!]!
}

# Autogenerated return type of RequestCoop
type RequestCoopPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  coopRequests: [CoopRequest!]
  errors: [String!]!
}

type Role {
  createdAt: Int!
  id: ID!
  name: String!
  permissionLevel: String!
  users: [User!]
}

# Autogenerated input type of ShareAchievement
input ShareAchievementInput {
  # Achievement to share
  achievementId: String

  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # User to send request to
  userIds: [String!]!
}

# Autogenerated return type of ShareAchievement
type ShareAchievementPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  errors: [String!]!
  shareRequests: [SharedAchievement!]
}

# Autogenerated input type of ShareList
input ShareListInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # Achievement to share
  listId: String

  # User to send request to
  userIds: [String!]!
}

# Autogenerated return type of ShareList
type ShareListPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  errors: [String!]!
  shareRequests: [SharedList!]
}

# Shared Achievements are achievements that a user have sent
# to another user. These can be any Achievement that the user
# has found in his feed, or list, or even on another users profile,
# and wanted to recommend somebody else; or it could be an
# Achievement the user has created which is not public, but that
# he or she wants a friend to be able to complete.
type SharedAchievement implements NotificationInterface {
  # The Achievement that's being shared
  achievement: Achievement!
  createdAt: Int!
  id: ID!

  # This indicates whether or not the receiving user is allowed to invite others to cooperate
  isInvitable: Boolean!

  # User who received the shared Achievement
  receiver: User!

  # Whether the user would like to cooperate on this. TODO: This should be a coop_request_id
  requestMultiPlayer: Boolean!

  # User who shared the Achievement
  sender: User!
}

# Shared Lists are lists that a user have sent
# to another user. These can be any List that the user
# has found in his feed, or even on another users profile,
# and wanted to recommend somebody else; or it could be a
# List the user has created which is not public, but that
# he or she wants a friend to be able to complete.
#
# A user may create a List for a backpacking trip the user
# is going on with a couple of friends, but without making
# the list public, it wouldn't be possible for other users
# to view the list.
#
# Instead, the user may share the list with their group of
# friends, and they would be able to view the Achievements
# in the list, even if these achievements aren't public.
# This way, users can make collaborative lists.
type SharedList implements NotificationInterface {
  id: ID!
  isInvitable: Boolean!

  # List that's being shared
  list: List!

  # User who receives the list
  receiver: User!

  # Whether the user would like to cooperate on this. TODO: This should be a coop_request_id
  requestMultiPlayer: Boolean!

  # User who shared the List
  sender: User!
}

type Subscription {
  # User received a notification
  notificationReceived: Notification
}

# When an Achievement becomes **Unlocked**, a container is created
# for it which adds metadata, e.g how many points were awarded for
# completing this Achievement, and whether or not any cooperation
# bonus points were awarded.
#
# This is used so that, for example, if two users are in multiplayer/coop
# mode, and one of them is offline, the user who is online will
# receive no coop bonus until the offline user goes online. When the
# offline user goes online, and the Achievement becomes Unlocked
# with a given timestamp for that user, both of their Unlocked
# Achievement will be updated with the given coop bonus provided
# they both unlocked the Achievement within 5 minutes of each other.
type Unlocked implements NotificationInterface {
  achievement: Achievement!

  # Whether or not this Achievement was completed as multiplayer / coop
  coop: Boolean!

  # Additional bonus points for completing the Achievement with another user. This
  # field will be 0 until any other users in the groups also complete the Achievement
  coopBonus: Float!
  createdAt: Int!
  id: ID!

  # Poins awarded for completing the Achievement, usually equals Achievement.points
  points: Float!

  # How many times a user has unlocked the same Achievement, if the Achievement can be done multiple times
  repetitionCount: Int!

  # User who unlocked this Achievement
  user: User!
}

# The connection type for Unlocked.
type UnlockedConnection {
  # A list of edges.
  edges: [UnlockedEdge]

  # A list of nodes.
  nodes: [Unlocked]

  # Information to aid in pagination.
  pageInfo: PageInfo!
}

# An edge in a connection.
type UnlockedEdge {
  # A cursor for use in pagination.
  cursor: String!

  # The item at the end of the edge.
  node: Unlocked
}

# Autogenerated input type of Update
input UpdateInput {
  categoryId: Int!

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  description: String!
  icon: String!
  id: String!
  mode: Mode!
  name: String!
  objectives: [ObjectiveInput!]!
}

# Autogenerated input type of UpdateList
input UpdateListInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # ID of the list to update
  id: String!

  # Whether or not this list should be visible for other users
  isPublic: Boolean = false

  # Name of the list
  title: String!
}

# Autogenerated return type of UpdateList
type UpdateListPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  errors: [String!]!
  list: List
}

# Autogenerated input type of UpdateMe
input UpdateMeInput {
  allowCoop: Boolean
  avatar: String

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  email: String
  name: String
}

# Autogenerated return type of UpdateMe
type UpdateMePayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  errors: [String!]!
  user: CurrentUser
}

# Autogenerated return type of Update
type UpdatePayload {
  achievement: Achievement

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  errors: [String!]!
}

# Autogenerated input type of Upvote
input UpvoteInput {
  # Achievement to upvote
  achievementId: String!

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
}

# Autogenerated return type of Upvote
type UpvotePayload {
  achievement: Achievement

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  errors: [String!]!
}

type User {
  allowCoop: Boolean!
  avatar: String
  coopPoints: Int!
  country: Country!
  email: String!
  id: ID!
  isFriend: Boolean!
  isPendingFriend: Boolean!

  # User's created lists
  lists(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the first _n_ elements from the list.
    first: Int

    # Returns the last _n_ elements from the list.
    last: Int
  ): ListConnection!
  name: String!
  personalPoints: Float!
  points: Float!
  role: Role!

  # All Achievements unlocked by the user
  unlockedAchievements(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the first _n_ elements from the list.
    first: Int

    # Returns the last _n_ elements from the list.
    last: Int
  ): UnlockedConnection!
  unlockedCount: Int!

  # All Achievements created by the user
  userAchievements(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the first _n_ elements from the list.
    first: Int

    # Returns the last _n_ elements from the list.
    last: Int
  ): AchievementConnection!
}

# The connection type for User.
type UserConnection {
  # A list of edges.
  edges: [UserEdge]

  # A list of nodes.
  nodes: [User]

  # Information to aid in pagination.
  pageInfo: PageInfo!
}

# An edge in a connection.
type UserEdge {
  # A cursor for use in pagination.
  cursor: String!

  # The item at the end of the edge.
  node: User
}